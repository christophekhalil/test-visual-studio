<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Ocean Scene (Modified)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.dom.min.js"></script>
    <style>
        html, body { margin: 0; padding: 0; overflow: hidden; }
    </style>
</head>
<body>
<script>
// ===================================================
// === GLOBAL VARIABLES & CONFIGURATION
// ===================================================
let storyStep = 1;
let slider, homeButton, resetButton, knob;
let vanishingPoint;
const horizonY = 0.2;
let flock = [];
const numBoids = 150;

// Sound Wave animation variables
let waveRadius = 0;
let waveOpacity = 200;

// ===================================================
// === P5.JS SETUP & MAIN DRAW LOOP
// ===================================================

function setup() {
    createCanvas(windowWidth, windowHeight);
    vanishingPoint = createVector(width / 2, height * horizonY);
    createUI();
    for (let i = 0; i < numBoids; i++) {
        flock.push(new Boid(random(width), random(height * horizonY, height)));
    }
}

function draw() {
    storyStep = slider.value();
    drawBackground();
    drawSeabed();
    drawWindmill();
    runFlock();
    drawUI();

    knob.updateVisibility(storyStep === 4);
    if (knob.visible) {
        knob.display();
    }
}

// ===================================================
// === SCENE & BACKGROUND DRAWING FUNCTIONS
// ===================================================

function drawBackground() {
    background(135, 206, 235); // Sky
    fill(0, 105, 148); // Ocean
    noStroke();
    rect(0, height * horizonY, width, height * (1 - horizonY));

    // Mountains
    fill(110, 120, 130);
    beginShape(); vertex(0, height * horizonY); vertex(width * 0.1, height * 0.15); vertex(width * 0.2, height * 0.1); vertex(width * 0.3, height * horizonY); endShape(CLOSE);
    beginShape(); vertex(width, height * horizonY); vertex(width * 0.9, height * 0.17); vertex(width * 0.8, height * 0.12); vertex(width * 0.7, height * horizonY); endShape(CLOSE);
}

function drawSeabed() {
    stroke(0, 80, 120, 150);
    strokeWeight(2);
    for (let i = 0; i < width; i += 50) {
        line(i, height, vanishingPoint.x, vanishingPoint.y);
    }
}

function drawWindmill() {
    if (storyStep < 2) return;

    const baseWidth = 150;
    const structureHeight = height * 0.75; 

    // --- Draw Base Structure ---
    push();
    translate(vanishingPoint.x, height);
    stroke(60); strokeWeight(4); fill(80);
    line(-baseWidth / 2, 0, -baseWidth / 4, -structureHeight);
    line(baseWidth / 2, 0, baseWidth / 4, -structureHeight);
    rectMode(CORNERS);
    rect(-baseWidth/4, -structureHeight, baseWidth/4, -structureHeight-10);
    pop();

    // --- Draw Disturbance Sound Waves (step 3 & unprotected step 4) ---
    if (storyStep === 3 || (storyStep === 4 && knob.value < 1.0)) {
        push();
        translate(vanishingPoint.x, height - structureHeight);
        waveRadius += 1.5;
        waveOpacity -= 2;
        if (waveOpacity <= 0) {
            waveRadius = 0;
            waveOpacity = 200;
        }
        noFill(); strokeWeight(2);
        stroke(255, 255, 255, waveOpacity); circle(0, 0, waveRadius);
        stroke(255, 255, 255, waveOpacity * 0.66); circle(0, 0, waveRadius * 0.66);
        stroke(255, 255, 255, waveOpacity * 0.33); circle(0, 0, waveRadius * 0.33);
        pop();
    }

    // --- Draw Protective Cover (step 4 only) ---
    if (storyStep === 4) {
        push();
        translate(vanishingPoint.x, height - structureHeight);
        noFill(); strokeWeight(10); stroke(0, 255, 255, 150);
        let angle = map(knob.value, 0, 1, 0, TWO_PI);
        if (angle > 0) { // Only draw if there is something to show
            arc(0, 0, 150, 150, -PI/2, -PI/2 + angle);
        }
        pop();
    }
}

// ===================================================
// === UI DRAWING AND MANAGEMENT
// ===================================================

function createUI() {
    slider = createSlider(1, 4, 1, 1);
    slider.position(width - 220, height - 45);
    slider.style('width', '180px');
    
    homeButton = createButton('Home');
    homeButton.position(width - 80, 20);
    homeButton.mousePressed(resetSketch);

    resetButton = createButton('Reset');
    resetButton.position(20, 20);
    resetButton.mousePressed(resetSketch);

    // MODIFIED: Knob is 3x bigger (90) and moved left to accommodate its size.
    knob = new Knob(width - 320, height - 45, 90);
}

function drawUI() {
    const barHeight = height * 0.05;
    fill(0, 0, 0, 100);
    noStroke();
    rect(0, height - barHeight - 10, width, barHeight);

    let infoText = ""; // Empty text as requested
    fill(255); textSize(16); textAlign(CENTER, CENTER);
    text(infoText, width / 2, height - barHeight / 2 - 10);
}

function resetSketch() {
    slider.value(1);
    knob.reset();
}

// ===================================================
// === FLOCKING SIMULATION (BOIDS)
// ===================================================

function runFlock() {
    for (let boid of flock) boid.run(flock);
}

class Boid {
    constructor(x, y) {
        this.position = createVector(x, y);
        this.velocity = p5.Vector.random2D();
        this.velocity.setMag(random(2, 4));
        this.acceleration = createVector();
        this.maxForce = 0.2;
        this.maxSpeed = 4;
    }

    run(boids) {
        this.flock(boids);
        this.update();
        this.borders();
        this.render();
    }

    applyForce(force) { this.acceleration.add(force); }
    update() {
        this.velocity.add(this.acceleration);
        this.velocity.limit(this.maxSpeed);
        this.position.add(this.velocity);
        this.acceleration.mult(0);
    }

    flock(boids) {
        let sep = this.separation(boids).mult(2.5);
        let ali = this.align(boids).mult(1.0);
        let coh = this.cohesion(boids).mult(1.0);
        this.applyForce(sep); this.applyForce(ali); this.applyForce(coh);

        // MODIFIED: Fish are disturbed in step 3 OR step 4 until knob is fully turned
        if (storyStep === 3 || (storyStep === 4 && knob.value < 1.0)) {
            let fleePoint = createVector(width / 2, height * 0.7);
            let fleeForce = this.flee(fleePoint).mult(3.0);
            this.applyForce(fleeForce);
            this.maxSpeed = 7; // Agitated speed
        } else {
            this.maxSpeed = 4; // Normal speed
        }
    }

    borders() {
        if (this.position.x < -10) this.position.x = width + 10;
        if (this.position.y < height * horizonY) this.position.y = height + 10;
        if (this.position.x > width + 10) this.position.x = -10;
        if (this.position.y > height + 10) this.position.y = height*horizonY;
    }

    render() {
        let size = map(this.position.y, height * horizonY, height, 2, 12);
        let angle = this.velocity.heading() + PI / 2;
        push();
        translate(this.position.x, this.position.y);
        rotate(angle);
        fill(200, 200, 220); stroke(150);
        beginShape(); vertex(0, -size); vertex(-size / 2, size); vertex(size / 2, size); endShape(CLOSE);
        pop();
    }

    seek(target) {
        let desired = p5.Vector.sub(target, this.position).setMag(this.maxSpeed);
        let steer = p5.Vector.sub(desired, this.velocity).limit(this.maxForce);
        return steer;
    }
    
    flee(target) { return this.seek(target).mult(-1); }

    separation(boids) {
        let desiredSeparation = 25.0, steer = createVector(0, 0), count = 0;
        for (let other of boids) {
            let d = p5.Vector.dist(this.position, other.position);
            if ((d > 0) && (d < desiredSeparation)) {
                let diff = p5.Vector.sub(this.position, other.position).normalize().div(d);
                steer.add(diff); count++;
            }
        }
        if (count > 0) steer.div(count);
        if (steer.mag() > 0) steer.setMag(this.maxSpeed).sub(this.velocity).limit(this.maxForce);
        return steer;
    }

    align(boids) {
        let neighborDist = 50, sum = createVector(0, 0), count = 0;
        for (let other of boids) {
            let d = p5.Vector.dist(this.position, other.position);
            if ((d > 0) && (d < neighborDist)) { sum.add(other.velocity); count++; }
        }
        if (count > 0) {
            sum.div(count).setMag(this.maxSpeed);
            return p5.Vector.sub(sum, this.velocity).limit(this.maxForce);
        } else return createVector(0, 0);
    }

    cohesion(boids) {
        let neighborDist = 50, sum = createVector(0, 0), count = 0;
        for (let other of boids) {
            let d = p5.Vector.dist(this.position, other.position);
            if ((d > 0) && (d < neighborDist)) { sum.add(other.position); count++; }
        }
        if (count > 0) { sum.div(count); return this.seek(sum); } 
        else return createVector(0, 0);
    }
}

// ===================================================
// === KNOB CLASS & MOUSE INTERACTIONS
// ===================================================
class Knob {
    constructor(x, y, size) {
        this.x = x; this.y = y; this.size = size;
        this.value = 0; this.angle = -PI / 2;
        this.isDragging = false; this.visible = false;
    }
    updateVisibility(isVisible) { this.visible = isVisible; }
    handleDrag() { if (this.visible && dist(mouseX, mouseY, this.x, this.y) < this.size / 2) this.isDragging = true; }
    drag() {
        if (this.isDragging) {
            let dx = mouseX - pmouseX;
            this.angle += dx * 0.05;
            this.angle = constrain(this.angle, -PI / 2, PI * 1.5);
            this.value = map(this.angle, -PI / 2, PI * 1.5, 0, 1);
        }
    }
    stopDrag() { this.isDragging = false; }
    reset() { this.angle = -PI / 2; this.value = 0; }
    display() {
        push();
        translate(this.x, this.y);
        rotate(this.angle);
        stroke(40); strokeWeight(3); fill(150);
        // Draw the 3 blades
        for (let i = 0; i < 3; i++) {
            rectMode(CORNER);
            rect(-5, -10, 10, this.size / 2);
            rotate(TWO_PI / 3);
        }
        // Draw the central hub
        fill(80); noStroke();
        circle(0, 0, this.size / 4);
        pop();
    }
}

function mousePressed() { knob.handleDrag(); }
function mouseDragged() { knob.drag(); }
function mouseReleased() { knob.stopDrag(); }

// ===================================================
// === RESPONSIVE DESIGN
// ===================================================

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    vanishingPoint.set(width / 2, height * horizonY);
    slider.position(width - 220, height - 45);
    homeButton.position(width - 80, 20);
    resetButton.position(20, 20);
    // Adjust knob position on resize
    knob.x = width - 320;
    knob.y = height - 45;
}
</script>
</body>
</html>