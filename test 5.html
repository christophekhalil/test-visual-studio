<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Ocean Scene (Visual Upgrade)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.dom.min.js"></script>
    <style>
        html, body { margin: 0; padding: 0; overflow: hidden; }
    </style>
</head>
<body>
<script>
// ===================================================
// === GLOBAL VARIABLES & CONFIGURATION
// ===================================================
let storyStep = 1;
let slider, homeButton, resetButton, knob;
let vanishingPoint;
const horizonY = 0.2; // Original horizon for mountains
let flock = [];
const numBoids = 150;

// New Color Palette (from your example)
const SKY_COLOR = '#E0F7FA';
const WATER_COLOR = '#42A5F5';
const DEEP_WATER_COLOR = '#1E88E5'; // A slightly deeper blue for the gradient
const MOUNTAIN_COLOR = '#B0BEC5'; // Changed for better contrast
const TURBINE_COLOR = '#B0BEC5';
const SOCK_COLOR = '#66BB6A';
const FISH_COLOR = '#455A64';

// ===================================================
// === P5.JS SETUP & MAIN DRAW LOOP
// ===================================================

function setup() {
    createCanvas(windowWidth, windowHeight);
    vanishingPoint = createVector(width / 2, height * horizonY);
    createUI();
    // Use the water level from the new sketch for fish placement
    const waterLevel = height * 0.5;
    for (let i = 0; i < numBoids; i++) {
        flock.push(new Boid(random(width), random(waterLevel, height)));
    }
}

function draw() {
    storyStep = slider.value();
    drawBackground();
    runFlock();
    drawWindmill(); // Draw windmill on top of fish
    drawUI();

    knob.updateVisibility(storyStep === 4);
    if (knob.visible) {
        knob.display();
    }
}

// ===================================================
// === SCENE & BACKGROUND DRAWING FUNCTIONS
// ===================================================

function drawBackground() {
    background(SKY_COLOR);
    const waterLevel = height * 0.5; // Use the 50% water level from new sketch

    // Mountains (using original horizonY)
    fill(MOUNTAIN_COLOR);
    noStroke();
    beginShape(); vertex(0, waterLevel); vertex(width * 0.1, height * 0.3); vertex(width * 0.25, height * 0.2); vertex(width * 0.4, waterLevel); endShape(CLOSE);
    beginShape(); vertex(width, waterLevel); vertex(width * 0.9, height * 0.25); vertex(width * 0.7, height * 0.15); vertex(width * 0.6, waterLevel); endShape(CLOSE);

    // Water with Gradient
    const c1 = color(WATER_COLOR);
    const c2 = color(DEEP_WATER_COLOR);
    for(let y = waterLevel; y < height; y++){
        const inter = map(y, waterLevel, height, 0, 1);
        const c = lerpColor(c1, c2, inter);
        stroke(c);
        line(0, y, width, y);
    }
}


// ===================================================
// === NEW INTEGRATED WINDMILL FUNCTION
// ===================================================
function drawWindmill() {
    if (storyStep < 2) return; // Only draw from step 2 onwards

    // Constants from your sketch
    const waterLevel = height * 0.5;
    const towerX = width / 2;
    const towerWidthBase = width * 0.08;
    const towerWidthSurface = width * 0.06;
    const towerWidthTop = width * 0.04;
    const nacelleY = height * 0.25;

    // --- Tower ---
    noStroke();
    fill(TURBINE_COLOR);
    quad(towerX - towerWidthSurface / 2, waterLevel, towerX + towerWidthSurface / 2, waterLevel, towerX + towerWidthBase / 2, height, towerX - towerWidthBase / 2, height);
    fill(236, 239, 241);
    quad(towerX - towerWidthTop / 2, nacelleY, towerX + towerWidthTop / 2, nacelleY, towerX + towerWidthSurface / 2, waterLevel, towerX - towerWidthSurface / 2, waterLevel);

    // --- Nacelle (head) ---
    const nacelleWidth = width * 0.08;
    const nacelleHeight = height * 0.05;
    fill('#B0BEC5');
    stroke('#78909C');
    strokeWeight(1);
    rect(towerX - nacelleWidth / 2, nacelleY - nacelleHeight, nacelleWidth, nacelleHeight, 4);

    // --- Hub and Blades ---
    const hubX = towerX;
    const hubY = nacelleY - nacelleHeight / 2;
    fill(245);
    noStroke();
    const hubSize = width * 0.03;
    ellipse(hubX, hubY, hubSize, hubSize);

    push();
    translate(hubX, hubY);
    rotate(frameCount / 200.0);
    const bladeLength = hubY - 5;
    const bladeWidth = width * 0.035;
    for (let i = 0; i < 3; i++) {
        rotate((TWO_PI / 3));
        fill(245);
        stroke(220);
        strokeWeight(1);
        ellipse(0, -bladeLength / 2, bladeWidth, bladeLength);
    }
    pop();

    // --- Construction Boat and Hammer ---
    noStroke();
    fill(240);
    const boatWidth = 80;
    const boatX = towerX - (towerWidthSurface / 2) - boatWidth - 10;
    rect(boatX, waterLevel - 20, boatWidth, 20);
    fill(224);
    rect(boatX + 10, waterLevel - 30, boatWidth - 20, 10);
    const hammerArmBaseX = boatX + 40;
    const hammerArmBaseY = waterLevel - 30;
    const hammerArmTopX = towerX;
    stroke(TURBINE_COLOR);
    strokeWeight(4);
    line(hammerArmBaseX, hammerArmBaseY, hammerArmTopX, waterLevel + 20);
    const hammerY = sin(frameCount * 0.1) * 10 + (waterLevel + 45);
    noStroke();
    fill(TURBINE_COLOR);
    rect(hammerArmTopX - 10, hammerY, 20, 15);

    // --- Animated "Sock" Protection (Step 4) ---
    if (storyStep === 4) {
        // The sock's height grows as the knob is turned
        const sockMaxHeight = height * 0.4;
        const sockCurrentHeight = sockMaxHeight * knob.value;
        if (sockCurrentHeight > 0) {
            const sockWidth = towerWidthBase + 10;
            const sockX = towerX - sockWidth / 2;
            fill(SOCK_COLOR);
            noStroke();
            rect(sockX, height - sockCurrentHeight, sockWidth, sockCurrentHeight);
            stroke(90, 160, 90, 200);
            strokeWeight(2);
            for (let i = 1; i < 4; i++) {
                const lineX = sockX + i * (sockWidth / 4);
                line(lineX, height - sockCurrentHeight, lineX, height);
            }
        }
    }

    // --- New Sound Wave Animation ---
    const shockwaveFrequency = 60;
    const shockwaveDuration = 25;
    if (storyStep === 3 || (storyStep === 4 && knob.value < 1.0)) {
        if (frameCount % shockwaveFrequency < shockwaveDuration) {
            noFill();
            const progress = (frameCount % shockwaveFrequency) / shockwaveDuration;
            const radius = progress * width / 1.5;
            const alpha = map(progress, 0, 1, 180, 0);
            stroke(255, alpha);
            strokeWeight(map(progress, 0, 1, 6, 0));
            // Draw wave originating from the base on the seafloor
            ellipse(towerX, height, radius, radius * 0.6);
        }
    }
}


// ===================================================
// === UI DRAWING AND MANAGEMENT
// ===================================================

function createUI() {
    slider = createSlider(1, 4, 1, 1);
    slider.position(width - 220, height - 45);
    slider.style('width', '180px');
    
    homeButton = createButton('Home');
    homeButton.position(width - 80, 20);
    homeButton.mousePressed(resetSketch);

    resetButton = createButton('Reset');
    resetButton.position(20, 20);
    resetButton.mousePressed(resetSketch);

    knob = new Knob(width - 320, height - 45, 90);
}

function drawUI() {
    const barHeight = height * 0.05;
    fill(0, 0, 0, 100);
    noStroke();
    rect(0, height - barHeight - 10, width, barHeight);

    let infoText = ""; // Empty text as requested
    fill(255); textSize(16); textAlign(CENTER, CENTER);
    text(infoText, width / 2, height - barHeight / 2 - 10);
}

function resetSketch() {
    slider.value(1);
    knob.reset();
}

// ===================================================
// === FLOCKING SIMULATION (BOIDS)
// ===================================================

function runFlock() {
    for (let boid of flock) boid.run(flock);
}

class Boid {
    constructor(x, y) {
        this.position = createVector(x, y);
        this.velocity = p5.Vector.random2D().setMag(random(2, 4));
        this.acceleration = createVector();
        this.maxForce = 0.05; // Tuned for new logic
        this.maxSpeed = 3;
        this.r = 3.0;
    }

    run(boids) { this.flock(boids); this.update(); this.borders(); this.render(); }
    applyForce(force) { this.acceleration.add(force); }
    update() { this.velocity.add(this.acceleration); this.velocity.limit(this.maxSpeed); this.position.add(this.velocity); this.acceleration.mult(0); }

    flock(boids) {
        let sep = this.separation(boids).mult(1.5);
        let ali = this.align(boids).mult(1.0);
        let coh = this.cohesion(boids).mult(1.0);
        this.applyForce(sep); this.applyForce(ali); this.applyForce(coh);

        const fleePoint = createVector(width / 2, height); // Flee from the base of the turbine
        const fleeRadius = width / 2;

        if (storyStep === 3) {
            this.maxSpeed = 6;
            let d = p5.Vector.dist(this.position, fleePoint);
            if (d < fleeRadius) this.applyForce(this.flee(fleePoint).mult(2.0));
        } 
        else if (storyStep === 4) {
            let disturbanceFactor = 1.0 - knob.value;
            this.maxSpeed = map(knob.value, 0, 1, 6, 3);
            let d = p5.Vector.dist(this.position, fleePoint);
            if (d < fleeRadius) {
                 this.applyForce(this.flee(fleePoint).mult(2.0 * disturbanceFactor));
            }
        } 
        else {
            this.maxSpeed = 3;
        }
    }

    borders() {
        const waterLevel = height * 0.5;
        if (this.position.x < -this.r) this.position.x = width + this.r;
        if (this.position.x > width + this.r) this.position.x = -this.r;
        if (this.position.y < waterLevel) this.position.y = height + this.r; // Wrap from top to bottom
        if (this.position.y > height + this.r) this.position.y = waterLevel; // Wrap from bottom to top
    }

    render() {
        const theta = this.velocity.heading() + PI / 2;
        fill(FISH_COLOR);
        noStroke();
        push();
        translate(this.position.x, this.position.y);
        rotate(theta);
        beginShape();
        vertex(0, -this.r * 2);
        vertex(-this.r, this.r * 2);
        vertex(this.r, this.r * 2);
        endShape(CLOSE);
        pop();
    }

    seek(target) { return p5.Vector.sub(target, this.position).setMag(this.maxSpeed).sub(this.velocity).limit(this.maxForce); }
    flee(target) { return this.seek(target).mult(-1); }
    separation(boids) { let d_sep=25.0, s=createVector(0,0), c=0; for(let o of boids){ let d=p5.Vector.dist(this.position,o.position); if((d>0)&&(d<d_sep)){s.add(p5.Vector.sub(this.position,o.position).normalize().div(d));c++;}} if(c>0) s.div(c); if(s.mag()>0) s.setMag(this.maxSpeed).sub(this.velocity).limit(this.maxForce); return s; }
    align(boids) { let n_dist=50, sum=createVector(0,0), c=0; for(let o of boids){ if(p5.Vector.dist(this.position, o.position)<n_dist){sum.add(o.velocity);c++;}} return c>0 ? sum.div(c).setMag(this.maxSpeed).sub(this.velocity).limit(this.maxForce):createVector(0,0);}
    cohesion(boids) { let n_dist=50, sum=createVector(0,0), c=0; for(let o of boids){ if(p5.Vector.dist(this.position, o.position)<n_dist){sum.add(o.position);c++;}} return c>0 ? this.seek(sum.div(c)):createVector(0,0);}
}

// ===================================================
// === KNOB CLASS & MOUSE INTERACTIONS
// ===================================================
class Knob {
    constructor(x, y, size) { this.x=x;this.y=y;this.size=size;this.value=0;this.angle=-PI/2;this.isDragging=false;this.visible=false; }
    updateVisibility(v) { this.visible = v; }
    handleDrag() { if(this.visible&&dist(mouseX,mouseY,this.x,this.y)<this.size/2) this.isDragging=true; }
    drag() { if(this.isDragging){this.angle+= (mouseX - pmouseX)*0.05;this.angle=constrain(this.angle,-PI/2,PI*1.5);this.value=map(this.angle,-PI/2,PI*1.5,0,1);}}
    stopDrag() { this.isDragging = false; }
    reset() { this.angle = -PI / 2; this.value = 0; }
    display() {
        push();
        translate(this.x, this.y); rotate(this.angle);
        stroke(40); strokeWeight(3); fill(150);
        for(let i=0;i<3;i++){rectMode(CORNER);rect(-5,-10,10,this.size/2);rotate(TWO_PI/3);}
        fill(80); noStroke(); circle(0, 0, this.size/4);
        pop();
    }
}

function mousePressed() { knob.handleDrag(); }
function mouseDragged() { knob.drag(); }
function mouseReleased() { knob.stopDrag(); }

// ===================================================
// === RESPONSIVE DESIGN
// ===================================================
function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    vanishingPoint.set(width / 2, height * horizonY);
    slider.position(width - 220, height - 45);
    homeButton.position(width - 80, 20);
    resetButton.position(20, 20);
    knob.x = width - 320; knob.y = height - 45;
}
</script>
</body>
</html>