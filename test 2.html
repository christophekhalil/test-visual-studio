function drawWindmill() {
    if (storyStep < 2) return; // Don't draw if before step 2

    // --- MODIFICATION IS HERE ---
    // The original value was height * 0.6.
    // Increasing it to 0.75 makes the structure taller.
    const baseWidth = 150;
    const structureHeight = height * 0.75; // <-- TALLER WINDMILL BASE

    // --- Draw Base Structure (from step 2 onwards) ---
    push();
    // The drawing still starts from the bottom center of the canvas
    translate(vanishingPoint.x, height); 
    stroke(60);
    strokeWeight(4);
    fill(80);
    
    // The perspective lines now stretch further up because structureHeight is larger.
    line( -baseWidth / 2, 0, -baseWidth / 4, -structureHeight);
    line( baseWidth / 2, 0, baseWidth / 4, -structureHeight);
    
    // The top platform of the base is also drawn higher up.
    rectMode(CORNERS);
    rect(-baseWidth/4, -structureHeight, baseWidth/4, -structureHeight-10);
    pop();

    // --- Draw Disturbance Particles (step 3 only) ---
    if (storyStep === 3) {
        // ... (this part remains the same)
    }

    // --- Draw Protective Cover (step 4 only) ---
    if (storyStep === 4) {
        // The cover's position is also automatically updated because it's
        // based on the structureHeight variable.
        push();
        translate(vanishingPoint.x, height - structureHeight);
        noFill();
        strokeWeight(10);
        stroke(0, 255, 255, 150); 
        let angle = map(knob.value, 0, 1, 0, TWO_PI);
        arc(0, 0, 150, 150, -PI/2, -PI/2 + angle);
        pop();
    }
}```

By making this one change, the base will now appear significantly taller, reaching closer to the horizon line where the sky and ocean meet. All other elements, like the protective cover, will adjust automatically because their positions are based on that `structureHeight` variable.

### Full Updated Code

Here is the complete, ready-to-use HTML file with the taller windmill. You can copy and paste this entire block to see the result.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Ocean Scene (Taller Windmill)</title>
    <!-- Import p5.js and the p5.dom library for the slider -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.dom.min.js"></script>
    <style>
        /* Basic CSS to make the canvas fill the window */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevents scrollbars */
        }
    </style>
</head>
<body>
<script>
// ===================================================
// === GLOBAL VARIABLES & CONFIGURATION
// ===================================================
let storyStep = 1;

// UI Elements
let slider;
let homeButton, resetButton;
let knob;

// Scene
let vanishingPoint;
const horizonY = 0.2; // 20% from the top

// Fish Flocking (Boids)
let flock = [];
const numBoids = 150;

// ===================================================
// === P5.JS SETUP & MAIN DRAW LOOP
// ===================================================

function setup() {
    createCanvas(windowWidth, windowHeight);
    vanishingPoint = createVector(width / 2, height * horizonY);

    // --- Create UI Elements ---
    createUI();
    
    // --- Initialize the flock of fish ---
    for (let i = 0; i < numBoids; i++) {
        flock.push(new Boid(random(width), random(height * horizonY, height)));
    }
}

function draw() {
    // Update story step from slider
    storyStep = slider.value();

    // --- Drawing Layers (from back to front) ---
    drawBackground();
    drawSeabed();
    drawWindmill();

    // --- Run and draw the flocking simulation ---
    runFlock();
    
    // --- Draw UI on top of everything ---
    drawUI();

    // Show/hide knob based on the story step
    knob.updateVisibility(storyStep === 4);
    if (knob.visible) {
        knob.display();
    }
}

// ===================================================
// === SCENE & BACKGROUND DRAWING FUNCTIONS
// ===================================================

function drawBackground() {
    // Sky
    background(135, 206, 235); // Light sky blue
    // Ocean
    fill(0, 105, 148); // Deep ocean blue
    noStroke();
    rect(0, height * horizonY, width, height * (1 - horizonY));

    // Mountains
    fill(110, 120, 130);
    beginShape(); // Left mountain
    vertex(0, height * horizonY);
    vertex(width * 0.1, height * 0.15);
    vertex(width * 0.2, height * 0.1);
    vertex(width * 0.3, height * horizonY);
    endShape(CLOSE);
    
    beginShape(); // Right mountain
    vertex(width, height * horizonY);
    vertex(width * 0.9, height * 0.17);
    vertex(width * 0.8, height * 0.12);
    vertex(width * 0.7, height * horizonY);
    endShape(CLOSE);
}

function drawSeabed() {
    stroke(0, 80, 120, 150);
    strokeWeight(2);
    for (let i = 0; i < width; i += 50) {
        line(i, height, vanishingPoint.x, vanishingPoint.y);
    }
}

function drawWindmill() {
    if (storyStep < 2) return;

    const baseWidth = 150;
    // MODIFIED LINE: Changed from 0.6 to 0.75 to make the structure taller.
    const structureHeight = height * 0.75; 

    // --- Draw Base Structure ---
    push();
    translate(vanishingPoint.x, height);
    stroke(60);
    strokeWeight(4);
    fill(80);
    line(-baseWidth / 2, 0, -baseWidth / 4, -structureHeight);
    line(baseWidth / 2, 0, baseWidth / 4, -structureHeight);
    rectMode(CORNERS);
    rect(-baseWidth/4, -structureHeight, baseWidth/4, -structureHeight-10);
    pop();

    // --- Draw Disturbance Particles (step 3 only) ---
    if (storyStep === 3) {
        for(let i = 0; i < 5; i++){
            fill(255, 255, 255, random(50, 150));
            noStroke();
            let x = random(width/2 - 50, width/2 + 50);
            let y = random(height*0.5, height * 0.8);
            circle(x, y, random(5, 15));
        }
    }

    // --- Draw Protective Cover (step 4 only) ---
    if (storyStep === 4) {
        push();
        translate(vanishingPoint.x, height - structureHeight);
        noFill();
        strokeWeight(10);
        stroke(0, 255, 255, 150);
        let angle = map(knob.value, 0, 1, 0, TWO_PI);
        arc(0, 0, 150, 150, -PI/2, -PI/2 + angle);
        pop();
    }
}


// ===================================================
// === UI DRAWING AND MANAGEMENT
// ===================================================

function createUI() {
    slider = createSlider(1, 4, 1, 1);
    slider.position(width - 220, height - 45);
    slider.style('width', '180px');
    
    homeButton = createButton('Home');
    homeButton.position(width - 80, 20);
    homeButton.mousePressed(resetSketch);

    resetButton = createButton('Reset');
    resetButton.position(20, 20);
    resetButton.mousePressed(resetSketch);

    knob = new Knob(width - 280, height - 45, 30);
}

function drawUI() {
    const barHeight = height * 0.05;
    fill(0, 0, 0, 100);
    noStroke();
    rect(0, height - barHeight - 10, width, barHeight);

    let infoText = "";
    switch(storyStep) {
        case 1: infoText = ""; break;
        case 2: infoText = ""; break;
        case 3: infoText = ""; break;
        case 4: infoText = ""; break;
    }
    fill(255);
    textSize(16);
    textAlign(CENTER, CENTER);
    text(infoText, width / 2, height - barHeight / 2 - 10);
}

function resetSketch() {
    slider.value(1);
    knob.reset();
}


// ===================================================
// === FLOCKING SIMULATION (BOIDS)
// ===================================================

function runFlock() {
    for (let boid of flock) {
        boid.run(flock);
    }
}

class Boid {
    constructor(x, y) {
        this.position = createVector(x, y);
        this.velocity = p5.Vector.random2D();
        this.velocity.setMag(random(2, 4));
        this.acceleration = createVector();
        this.maxForce = 0.2;
        this.maxSpeed = 4;
    }

    run(boids) {
        this.flock(boids);
        this.update();
        this.borders();
        this.render();
    }

    update() {
        this.velocity.add(this.acceleration);
        this.velocity.limit(this.maxSpeed);
        this.position.add(this.velocity);
        this.acceleration.mult(0);
    }

    applyForce(force) {
        this.acceleration.add(force);
    }

    flock(boids) {
        let sep = this.separation(boids);
        let ali = this.align(boids);
        let coh = this.cohesion(boids);

        sep.mult(2.5);
        ali.mult(1.0);
        coh.mult(1.0);

        this.applyForce(sep);
        this.applyForce(ali);
        this.applyForce(coh);

        if (storyStep === 3) {
            let fleePoint = createVector(width / 2, height * 0.7);
            let fleeForce = this.flee(fleePoint);
            fleeForce.mult(3.0);
            this.applyForce(fleeForce);
            this.maxSpeed = 7;
        } else {
            this.maxSpeed = 4;
        }
    }

    borders() {
        if (this.position.x < -10) this.position.x = width + 10;
        if (this.position.y < height * horizonY) this.position.y = height + 10;
        if (this.position.x > width + 10) this.position.x = -10;
        if (this.position.y > height + 10) this.position.y = height*horizonY;
    }

    render() {
        let size = map(this.position.y, height * horizonY, height, 2, 12);
        let angle = this.velocity.heading() + PI / 2;
        
        push();
        translate(this.position.x, this.position.y);
        rotate(angle);
        fill(200, 200, 220);
        stroke(150);
        beginShape();
        vertex(0, -size);
        vertex(-size / 2, size);
        vertex(size / 2, size);
        endShape(CLOSE);
        pop();
    }

    seek(target) {
        let desired = p5.Vector.sub(target, this.position);
        desired.setMag(this.maxSpeed);
        let steer = p5.Vector.sub(desired, this.velocity);
        steer.limit(this.maxForce);
        return steer;
    }
    
    flee(target) {
        return this.seek(target).mult(-1);
    }

    separation(boids) {
        let desiredSeparation = 25.0;
        let steer = createVector(0, 0);
        let count = 0;
        for (let other of boids) {
            let d = p5.Vector.dist(this.position, other.position);
            if ((d > 0) && (d < desiredSeparation)) {
                let diff = p5.Vector.sub(this.position, other.position);
                diff.normalize();
                diff.div(d);
                steer.add(diff);
                count++;
            }
        }
        if (count > 0) steer.div(count);
        if (steer.mag() > 0) {
            steer.setMag(this.maxSpeed);
            steer.sub(this.velocity);
            steer.limit(this.maxForce);
        }
        return steer;
    }

    align(boids) {
        let neighborDist = 50;
        let sum = createVector(0, 0);
        let count = 0;
        for (let other of boids) {
            let d = p5.Vector.dist(this.position, other.position);
            if ((d > 0) && (d < neighborDist)) {
                sum.add(other.velocity);
                count++;
            }
        }
        if (count > 0) {
            sum.div(count);
            sum.setMag(this.maxSpeed);
            let steer = p5.Vector.sub(sum, this.velocity);
            steer.limit(this.maxForce);
            return steer;
        } else {
            return createVector(0, 0);
        }
    }

    cohesion(boids) {
        let neighborDist = 50;
        let sum = createVector(0, 0);
        let count = 0;
        for (let other of boids) {
            let d = p5.Vector.dist(this.position, other.position);
            if ((d > 0) && (d < neighborDist)) {
                sum.add(other.position);
                count++;
            }
        }
        if (count > 0) {
            sum.div(count);
            return this.seek(sum);
        } else {
            return createVector(0, 0);
        }
    }
}


// ===================================================
// === KNOB CLASS & MOUSE INTERACTIONS
// ===================================================
class Knob {
    constructor(x, y, size) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.value = 0;
        this.angle = -PI/2;
        this.isDragging = false;
        this.visible = false;
    }

    updateVisibility(isVisible) { this.visible = isVisible; }
    handleDrag() { if (this.visible && dist(mouseX, mouseY, this.x, this.y) < this.size / 2) this.isDragging = true; }
    drag() {
        if(this.isDragging) {
            let dx = mouseX - pmouseX;
            this.angle += dx * 0.05;
            this.angle = constrain(this.angle, -PI/2, PI*1.5);
            this.value = map(this.angle, -PI/2, PI*1.5, 0, 1);
        }
    }
    stopDrag() { this.isDragging = false; }
    reset() { this.angle = -PI/2; this.value = 0; }
    display() {
        push();
        translate(this.x, this.y);
        fill(80); stroke(50); strokeWeight(2); circle(0, 0, this.size);
        rotate(this.angle);
        stroke(255); strokeWeight(3); line(0, 0, this.size/2 - 5, 0);
        pop();
    }
}

function mousePressed() { knob.handleDrag(); }
function mouseDragged() { knob.drag(); }
function mouseReleased() { knob.stopDrag(); }

// ===================================================
// === RESPONSIVE DESIGN
// ===================================================

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    vanishingPoint.set(width / 2, height * horizonY);
    
    slider.position(width - 220, height - 45);
    homeButton.position(width - 80, 20);
    resetButton.position(20, 20);
    knob.x = width - 280;
    knob.y = height - 45;
}

// commentaire
</script>
</body>
</html>