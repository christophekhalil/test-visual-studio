<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Ocean Scene (Final Refinements)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.dom.min.js"></script>
    <style>
        html, body { margin: 0; padding: 0; overflow: hidden; }
    </style>
</head>
<body>
<script>
// ===================================================
// === GLOBAL VARIABLES & CONFIGURATION
// ===================================================
let storyStep = 1;
let slider, homeButton, resetButton, knob;
let flock = [];
const numBoids = 150;

// MODIFIED: Water level is now 5% higher (45% from the top)
const WATER_LEVEL_RATIO = 0.45;

// Color Palette
const SKY_COLOR = '#E0F7FA';
const WATER_COLOR = '#42A5F5';
const DEEP_WATER_COLOR = '#1E88E5';
const MOUNTAIN_COLOR = '#B0BEC5';
const TURBINE_COLOR = '#B0BEC5';
const SOCK_COLOR = '#66BB6A';

// Fish Type Colors
const FISH_A_COLOR = '#455A64';
const FISH_B_COLOR = '#78909C';

// ===================================================
// === P5.JS SETUP & MAIN DRAW LOOP
// ===================================================

function setup() {
    createCanvas(windowWidth, windowHeight);
    createUI();
    const waterLevel = height * WATER_LEVEL_RATIO;
    
    // MODIFIED: Create two types of fish
    for (let i = 0; i < numBoids; i++) {
        const startX = random(width);
        const startY = random(waterLevel, height);
        if (i < 100) { // 100 of Type A
            flock.push(new Boid(startX, startY, 'A'));
        } else { // 50 of Type B
            flock.push(new Boid(startX, startY, 'B'));
        }
    }
}

function draw() {
    storyStep = slider.value();
    drawBackground();
    runFlock();
    drawWindmill();
    drawUI();

    knob.updateVisibility(storyStep === 4);
    if (knob.visible) {
        knob.display();
    }
}

// ===================================================
// === SCENE & BACKGROUND DRAWING FUNCTIONS
// ===================================================

function drawBackground() {
    background(SKY_COLOR);
    const waterLevel = height * WATER_LEVEL_RATIO;

    // Mountains
    fill(MOUNTAIN_COLOR);
    noStroke();
    beginShape(); vertex(0, waterLevel); vertex(width * 0.1, height * 0.3); vertex(width * 0.25, height * 0.2); vertex(width * 0.4, waterLevel); endShape(CLOSE);
    beginShape(); vertex(width, waterLevel); vertex(width * 0.9, height * 0.25); vertex(width * 0.7, height * 0.15); vertex(width * 0.6, waterLevel); endShape(CLOSE);

    // Water with Gradient
    const c1 = color(WATER_COLOR);
    const c2 = color(DEEP_WATER_COLOR);
    for(let y = waterLevel; y < height; y++){
        const inter = map(y, waterLevel, height, 0, 1);
        const c = lerpColor(c1, c2, inter);
        stroke(c);
        line(0, y, width, y);
    }
}

// ===================================================
// === INTEGRATED WINDMILL FUNCTION
// ===================================================
function drawWindmill() {
    if (storyStep < 2) return;

    const waterLevel = height * WATER_LEVEL_RATIO;
    const towerX = width / 2;
    const towerWidthBase = width * 0.08;
    const towerWidthSurface = width * 0.06;
    const towerWidthTop = width * 0.04;
    const nacelleY = height * 0.25;

    // Tower & Nacelle
    noStroke();
    fill(TURBINE_COLOR);
    quad(towerX - towerWidthSurface / 2, waterLevel, towerX + towerWidthSurface / 2, waterLevel, towerX + towerWidthBase / 2, height, towerX - towerWidthBase / 2, height);
    fill(236, 239, 241);
    quad(towerX - towerWidthTop / 2, nacelleY, towerX + towerWidthTop / 2, nacelleY, towerX + towerWidthSurface / 2, waterLevel, towerX - towerWidthSurface / 2, waterLevel);
    const nacelleWidth = width * 0.08;
    const nacelleHeight = height * 0.05;
    fill('#B0BEC5'); stroke('#78909C'); strokeWeight(1);
    rect(towerX - nacelleWidth / 2, nacelleY - nacelleHeight, nacelleWidth, nacelleHeight, 4);

    // Hub and Blades
    const hubX = towerX; const hubY = nacelleY - nacelleHeight / 2;
    fill(245); noStroke(); ellipse(hubX, hubY, width * 0.03, width * 0.03);
    push();
    translate(hubX, hubY); rotate(frameCount / 200.0);
    const bladeLength = hubY - 5; const bladeWidth = width * 0.035;
    for (let i = 0; i < 3; i++) { rotate(TWO_PI/3); fill(245); stroke(220); strokeWeight(1); ellipse(0, -bladeLength/2, bladeWidth, bladeLength); }
    pop();

    // Construction Boat and Hammer
    noStroke(); fill(240); const boatWidth = 80; const boatX = towerX - (towerWidthSurface/2) - boatWidth - 10;
    rect(boatX, waterLevel - 20, boatWidth, 20); fill(224); rect(boatX + 10, waterLevel - 30, boatWidth - 20, 10);
    stroke(TURBINE_COLOR); strokeWeight(4); line(boatX + 40, waterLevel-30, towerX, waterLevel + 20);
    noStroke(); fill(TURBINE_COLOR); rect(towerX - 10, sin(frameCount*0.1)*10 + (waterLevel+45), 20, 15);

    // Animated "Sock" Protection (Step 4)
    if (storyStep === 4) {
        const sockMaxHeight = height * 0.4;
        const sockCurrentHeight = sockMaxHeight * knob.value;
        if (sockCurrentHeight > 0) {
            const sockWidth = towerWidthBase + 10; const sockX = towerX - sockWidth / 2;
            fill(SOCK_COLOR); noStroke();
            rect(sockX, height - sockCurrentHeight, sockWidth, sockCurrentHeight);
            stroke(90, 160, 90, 200); strokeWeight(2);
            for (let i = 1; i < 4; i++) { const lineX = sockX + i * (sockWidth/4); line(lineX, height - sockCurrentHeight, lineX, height); }
        }
    }

    // --- MODIFIED Sound Wave Animation ---
    const shockwaveFrequency = 90; // Slower (was 60)
    const shockwaveDuration = 40; // Longer duration to see the waves
    if (storyStep === 3 || (storyStep === 4 && knob.value < 1.0)) {
        if (frameCount % shockwaveFrequency < shockwaveDuration) {
            noFill();
            const progress = (frameCount % shockwaveFrequency) / shockwaveDuration;
            const radius = progress * width / 1.5;
            const alpha = map(progress, 0, 1, 180, 0);
            const baseWeight = map(progress, 0, 1, 6, 0);
            
            // Draw 4 concentric curves
            stroke(255, alpha); strokeWeight(baseWeight); ellipse(towerX, height, radius, radius * 0.6);
            stroke(255, alpha * 0.8); strokeWeight(baseWeight * 0.8); ellipse(towerX, height, radius * 0.8, radius * 0.48);
            stroke(255, alpha * 0.6); strokeWeight(baseWeight * 0.6); ellipse(towerX, height, radius * 0.6, radius * 0.36);
            stroke(255, alpha * 0.4); strokeWeight(baseWeight * 0.4); ellipse(towerX, height, radius * 0.4, radius * 0.24);
        }
    }
}

// ===================================================
// === UI DRAWING AND MANAGEMENT
// ===================================================

function createUI() {
    slider = createSlider(1, 4, 1, 1);
    slider.position(width - 220, height - 45);
    slider.style('width', '180px');
    
    homeButton = createButton('Home');
    homeButton.position(width - 80, 20);
    homeButton.mousePressed(resetSketch);

    resetButton = createButton('Reset');
    resetButton.position(20, 20);
    resetButton.mousePressed(resetSketch);

    // MODIFIED: Knob is 3% bigger
    knob = new Knob(width - 320, height - 45, 93);
}

function drawUI() {
    const barHeight = height * 0.05;
    fill(0, 0, 0, 100);
    noStroke();
    rect(0, height - barHeight - 10, width, barHeight);
    fill(255); textSize(16); textAlign(CENTER, CENTER);
    text("", width / 2, height - barHeight / 2 - 10);
}

function resetSketch() {
    slider.value(1);
    knob.reset();
}

// ===================================================
// === FLOCKING SIMULATION (BOIDS)
// ===================================================

function runFlock() {
    for (let boid of flock) boid.run(flock);
}

class Boid {
    constructor(x, y, type) {
        this.position = createVector(x, y);
        this.velocity = p5.Vector.random2D();
        this.acceleration = createVector();
        this.type = type;

        // MODIFIED: Set properties based on fish type
        if (this.type === 'A') { // Standard Fish
            this.maxSpeed = 3;
            this.maxForce = 0.05;
            this.color = color(FISH_A_COLOR);
            this.velocity.setMag(random(1.5, 3));
        } else { // Type B: Skittish Fish
            this.maxSpeed = 4.5;
            this.maxForce = 0.07;
            this.color = color(FISH_B_COLOR);
            this.velocity.setMag(random(3, 4.5));
        }
    }

    run(boids) { this.flock(boids); this.update(); this.borders(); this.render(); }
    applyForce(force) { this.acceleration.add(force); }
    update() { this.velocity.add(this.acceleration); this.velocity.limit(this.maxSpeed); this.position.add(this.velocity); this.acceleration.mult(0); }

    flock(boids) {
        // Apply different flocking multipliers based on type for varied behavior
        let sepM = (this.type === 'A') ? 1.5 : 1.8;
        let aliM = (this.type === 'A') ? 1.0 : 0.8;
        let cohM = (this.type === 'A') ? 1.0 : 0.7;

        let sep = this.separation(boids).mult(sepM);
        let ali = this.align(boids).mult(aliM);
        let coh = this.cohesion(boids).mult(cohM);
        this.applyForce(sep); this.applyForce(ali); this.applyForce(coh);

        const fleePoint = createVector(width / 2, height);
        const fleeRadius = width / 2;
        let baseSpeed = (this.type === 'A') ? 3 : 4.5;
        let agitatedSpeed = (this.type === 'A') ? 6 : 7.5;

        if (storyStep === 3) {
            this.maxSpeed = agitatedSpeed;
            if (p5.Vector.dist(this.position, fleePoint) < fleeRadius) this.applyForce(this.flee(fleePoint).mult(2.0));
        } 
        else if (storyStep === 4) {
            let disturbanceFactor = 1.0 - knob.value;
            this.maxSpeed = map(knob.value, 0, 1, agitatedSpeed, baseSpeed);
            if (p5.Vector.dist(this.position, fleePoint) < fleeRadius) {
                 this.applyForce(this.flee(fleePoint).mult(2.0 * disturbanceFactor));
            }
        } 
        else {
            this.maxSpeed = baseSpeed;
        }
    }

    borders() {
        const waterLevel = height * WATER_LEVEL_RATIO;
        const r = 10; // buffer
        if (this.position.x < -r) this.position.x = width + r;
        if (this.position.x > width + r) this.position.x = -r;
        if (this.position.y < waterLevel) this.position.y = height + r;
        if (this.position.y > height + r) this.position.y = waterLevel;
    }

    render() {
        // MODIFIED: Implement depth perspective for size
        const waterLevel = height * WATER_LEVEL_RATIO;
        const size = map(this.position.y, waterLevel, height, 4, 12);
        
        const theta = this.velocity.heading() + PI / 2;
        fill(this.color);
        noStroke();
        push();
        translate(this.position.x, this.position.y);
        rotate(theta);
        beginShape();
        vertex(0, -size);
        vertex(-size/2, size);
        vertex(size/2, size);
        endShape(CLOSE);
        pop();
    }

    seek(target) { return p5.Vector.sub(target, this.position).setMag(this.maxSpeed).sub(this.velocity).limit(this.maxForce); }
    flee(target) { return this.seek(target).mult(-1); }
    separation(boids) { let d_sep=25.0, s=createVector(0,0), c=0; for(let o of boids){ let d=p5.Vector.dist(this.position,o.position); if((d>0)&&(d<d_sep)){s.add(p5.Vector.sub(this.position,o.position).normalize().div(d));c++;}} if(c>0) s.div(c); if(s.mag()>0) s.setMag(this.maxSpeed).sub(this.velocity).limit(this.maxForce); return s; }
    align(boids) { let n_dist=50, sum=createVector(0,0), c=0; for(let o of boids){ if(o!==this && p5.Vector.dist(this.position, o.position)<n_dist){sum.add(o.velocity);c++;}} return c>0 ? sum.div(c).setMag(this.maxSpeed).sub(this.velocity).limit(this.maxForce):createVector(0,0);}
    cohesion(boids) { let n_dist=50, sum=createVector(0,0), c=0; for(let o of boids){ if(o!==this && p5.Vector.dist(this.position, o.position)<n_dist){sum.add(o.position);c++;}} return c>0 ? this.seek(sum.div(c)):createVector(0,0);}
}

// ===================================================
// === KNOB CLASS & MOUSE INTERACTIONS
// ===================================================
class Knob {
    constructor(x, y, size) { this.x=x;this.y=y;this.size=size;this.value=0;this.angle=-PI/2;this.isDragging=false;this.visible=false; }
    updateVisibility(v) { this.visible = v; }
    handleDrag() { if(this.visible&&dist(mouseX,mouseY,this.x,this.y)<this.size/2) this.isDragging=true; }
    drag() { if(this.isDragging){this.angle+= (mouseX - pmouseX)*0.05;this.angle=constrain(this.angle,-PI/2,PI*1.5);this.value=map(this.angle,-PI/2,PI*1.5,0,1);}}
    stopDrag() { this.isDragging = false; }
    reset() { this.angle = -PI / 2; this.value = 0; }
    display() {
        push();
        translate(this.x, this.y); rotate(this.angle);
        stroke(40); strokeWeight(3); fill(150);
        for(let i=0;i<3;i++){rectMode(CORNER);rect(-5,-10,10,this.size/2);rotate(TWO_PI/3);}
        fill(80); noStroke(); circle(0, 0, this.size/4);
        pop();
    }
}

function mousePressed() { knob.handleDrag(); }
function mouseDragged() { knob.drag(); }
function mouseReleased() { knob.stopDrag(); }

// ===================================================
// === RESPONSIVE DESIGN
// ===================================================
function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    slider.position(width - 220, height - 45);
    homeButton.position(width - 80, 20);
    resetButton.position(20, 20);
    knob.x = width - 320; knob.y = height - 45;
}
</script>
</body>
</html>